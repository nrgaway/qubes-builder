#!/bin/bash +e
# vim: set ts=4 sw=4 sts=4 et :

CONF_MASTER_DIR=./example-configs
CONF_MASTER_FILE=nrgaway.conf
CONF_FILE=./setup.conf
CONF_FILE_OLD=./setup-old.conf

DIALOG=/usr/bin/dialog


# ------------------------------------------------------------------------------
# Colors
# ------------------------------------------------------------------------------
colors() {
   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/037
   ## Variables for terminal requests.
   [[ -t 2 ]] && {
       export alt=$(      tput smcup  || tput ti      ) # Start alt display
       export ealt=$(     tput rmcup  || tput te      ) # End   alt display
       export hide=$(     tput civis  || tput vi      ) # Hide cursor
       export show=$(     tput cnorm  || tput ve      ) # Show cursor
       export save=$(     tput sc                     ) # Save cursor
       export load=$(     tput rc                     ) # Load cursor
       export bold=$(     tput bold   || tput md      ) # Start bold
       export stout=$(    tput smso   || tput so      ) # Start stand-out
       export estout=$(   tput rmso   || tput se      ) # End stand-out
       export under=$(    tput smul   || tput us      ) # Start underline
       export eunder=$(   tput rmul   || tput ue      ) # End   underline
       export reset=$(    tput sgr0   || tput me      ) # Reset cursor
       export blink=$(    tput blink  || tput mb      ) # Start blinking
       export italic=$(   tput sitm   || tput ZH      ) # Start italic
       export eitalic=$(  tput ritm   || tput ZR      ) # End   italic
   [[ ${TERM} != *-m ]] && {
       export red=$(      tput setaf 1|| tput AF 1    )
       export green=$(    tput setaf 2|| tput AF 2    )
       export yellow=$(   tput setaf 3|| tput AF 3    )
       export blue=$(     tput setaf 4|| tput AF 4    )
       export magenta=$(  tput setaf 5|| tput AF 5    )
       export cyan=$(     tput setaf 6|| tput AF 6    )
   }
       export white=$(    tput setaf 7|| tput AF 7    )
       export default=$(  tput op                     )
       export eed=$(      tput ed     || tput cd      )   # Erase to end of display
       export eel=$(      tput el     || tput ce      )   # Erase to end of line
       export ebl=$(      tput el1    || tput cb      )   # Erase to beginning of line
       export ewl=$eel$ebl                                # Erase whole line
       export draw=$(     tput -S <<< '   enacs
                                   smacs
                                   acsc
                                   rmacs' || { \
                   tput eA; tput as;
                   tput ac; tput ae;         } )   # Drawing characters
       export back=$'\b'
   } 2>/dev/null ||:

   export build_already_defined_colors="true"
}

if [ ! "$build_already_defined_colors" = "true" ]; then
   colors
fi


# ------------------------------------------------------------------------------
# Display messages in color
# ------------------------------------------------------------------------------
# Only output text under certain conditions
output() {
    # Don't echo if -x is set since it will already be displayed via true
    [[ ${-/x} != $- ]] || echo -e "${1}"
}

info() {
    output "${bold}${blue}${1}${reset}" || :
}

debug() {
    output "${bold}${green}${1}${reset}" || :
}

warn() {
    output "${stout}${yellow}${1}${reset}" || :
}

error() {
    output "${bold}${red}${1}${reset}" || :
}


# ------------------------------------------------------------------------------
# Takes an array and exports it a global variable
#
# $1: Array to export
# $2: Global variable name to use for export
#
# http://ihaveabackup.net/2012/01/29/a-workaround-for-passing-arrays-in-bash/
#
# ------------------------------------------------------------------------------
setArrayAsGlobal() {
    local array="$1"
    local export_as="$2"
    local code=$(declare -p "$array")
    local replaced="${code/$array/$export_as}"
    eval ${replaced/declare -/declare -g}
} 

# ------------------------------------------------------------------------------
# $1: element to check for
# $2: array to check for element in
# ------------------------------------------------------------------------------
elementIn () {
  local element
  for element in "${@:2}"; do [[ "$element" == "$1" ]] && return 0; done
  return 1
}


# ------------------------------------------------------------------------------
# Install 'dialog' program if it does not yet exist
# ------------------------------------------------------------------------------
installDialog() {
    if [ ! -f "$DIALOG" ]; then
        _dialog="${DIALOG##*/}"
        info "${red}${_dialog}${blue} is not installed and required for setup."
        echo
        read -p "Enter 'Y' to install now or anything else to quit [YyNnQq]: " -r
        if [[ ! $REPLY =~ ^[]|[Yy]$ ]] && [[ -n $REPLY ]]; then
            error "You selected not to install ${blue}${_dialog}${red} and therefore setup must now exit"
            error "Exiting!"
            exit 1
        fi

        exec sudo yum -y install ${_dialog} 2>&1 > /dev/null &
        pid=$!

        info "Waiting for ${red}${_dialog}${blue} to install"
        while ps -p$pid 2>&1 > /dev/null; do
            printf "${red}.${reset}"
            sleep 1
        done
        echo
    fi
}

# ------------------------------------------------------------------------------
# chooseVersion
# ------------------------------------------------------------------------------
chooseVersion() {
    title="Choose Qubes Version"
    message="Choose which version of Qubes you wish to build.\n\nValid options are either the stable release 2 or development release 3 version." 
    dialog --default-button yes --yes-label "Release 2" --no-label "Release 3" --title "${title}" --yesno "${message}" 8 60
        return $?
}

# ------------------------------------------------------------------------------
# sshAccessDialog
# ------------------------------------------------------------------------------
sshAccessDialog() {
    title="Enable SSH Access"
    message="Do you have ssh access to the repos?\n\nSelect 'Yes' to configure urls to match git or 'No' for https" 
    dialog --default-button no --title "${title}" --yesno "${message}" 8 60
        return $?
}


# ------------------------------------------------------------------------------
# templateOnlyDialog
# ------------------------------------------------------------------------------
templateOnlyDialog() {
    title="Build Template Only?"
    message="Would you like to build only the templates?\n\nSelect 'Yes' to to only build templates or 'No' for complete build" 
    dialog --default-button yes --title "${title}" --yesno "${message}" 8 60
        return $?
}


# ------------------------------------------------------------------------------
# Check / Install Keys
# ------------------------------------------------------------------------------
#declare -A KEYS
read -r -d '' KEYS[0x36879494] <<'EOF' || true
(
    [key]="427F11FD0FAA4B080123F01CDDFA1A3E36879494"
    [key_short]=0x36879494 
    [owner]="Qubes Master Signing Key" 
    [fingerprint]="427F 11FD 0FAA 4B08 0123  F01C DDFA 1A3E 3687 9494"
    [verify]="fpr:::::::::427F11FD0FAA4B080123F01CDDFA1A3E36879494:"
    [url]="https://wiki.qubes-os.org/wiki/VerifyingSignatures"
)
EOF
read -r -d '' KEYS[0x5A4C6DAD] <<'EOF' || true
(
    [key]="E0E32283FDCAC1A510078F271BB9B1FB5A4C6DAD"
    [key_short]=0x5A4C6DAD 
    [owner]="Jason Mehring (Qubes OS Signing Key) <nrgaway@gmail.com>"
    [fingerprint]="E0E3 2283 FDCA C1A5 1007  8F27 1BB9 B1FB 5A4C 6DAD"
    [verify]="fpr:::::::::E0E32283FDCAC1A510078F271BB9B1FB5A4C6DAD:"
    [url]=""
)
EOF

gpgListKey() {
    text="$(gpg --list-key $1)" && retval=0 || retval=1
    echo "${text}"
    return $retval
}

gpgRecvKeys() {
    text="$(gpg --recv-keys $1)" && retval=0 || retval=1
    echo "${text}"
    return $retval
}

gpgVerifyKey() {
    text="$(gpg --with-colons --fingerprint $1)" && retval=0 || retval=1

    while read -r line; do
        if [ "${line:0:4}" == "fpr:" ]; then
            if [ "${line:$[${#line} - ${#1} -1]:-1}" != "${1}" ]; then
                echo "$(gpg --fingerprint $1)" || true
                return 1
            fi
        fi
    done <<< "${text}"

    echo "${text}"
    return $retval
}

checkKeys() {
    echo "Parsing keys..."
    for key in "${!KEYS[@]}"; do
        eval "declare -A key="${KEYS[key]}
        echo ${key[owner]}

        # Check if key exists
        text="$(gpgListKey ${key[key]})"
        if [ $? != "0" ]; then
            title="Add Keys"
            message="${key[owner]} key does not exist.\n\nSelect 'Yes' to add or 'No' to exit"
            dialog --default-button yes --title "${title}" --yesno "${message}" 8 60
                if [ $? != "0" ]; then
                    exit 1
                else
                    gpgRecvKeys ${key[key]}
                fi
        fi

        # Verify key
        text="$(gpgVerifyKey ${key[key]})"
        if [ $? != "0" ]; then
            title="${key[owner]} fingerprint failed!"
            message="\nWrong fingerprint:\n${key[fingerprint]}\n\nExiting!"
            dialog --title "${title}" --infobox "${message}" 8 60
            echo
            echo "${text}"
            exit 1
        fi

        # Add developers keys
        gpg --import qubes-developers-keys.asc 
    done
}


# ------------------------------------------------------------------------------
# Display VM's for selction
# ------------------------------------------------------------------------------
chooseDistsDialog() {
    return_global_var=${1}

    counter=1
    options=()
    for dist in ${DISTS_VM[@]}; do
        elementIn "$dist" ${SELECTED_DISTS_VM[@]} && toggle='on' || toggle='off'
        options+=("${counter} "${dist}" $toggle")
        counter=$[counter + 1]
    done

    cmd=($DIALOG --separate-output --checklist "Select options:" 22 76 16)
    choices=$("${cmd[@]}" ${options[@]} 2>&1 >/dev/tty)

    # Exit on cancel
    if [ $? != 0 ]; then
        exit 1
    fi

    DISTS=()
    for choice in $choices; do
        DISTS+=("${DISTS_VM[$[choice - 1]]}")
    done
    
    setArrayAsGlobal DISTS $return_global_var
}


# ------------------------------------------------------------------------------
# Write Configuration file
# ------------------------------------------------------------------------------
writeConfiguration() {
    dists=($@)

    echo "DISTS_VM :=" > ${CONF_FILE}
    for dist in ${dists[@]}; do
        echo "DISTS_VM += ${dist}" >> "${CONF_FILE}"
    done
}


# ------------------------------------------------------------------------------
# Summary
# ------------------------------------------------------------------------------
comment() {

    echo -e "\n#" >> "${CONF_FILE}"
    for line in "$@"; do
        echo -e "# ${line}" >> "${CONF_FILE}"
    done
    echo -e "#" >> "${CONF_FILE}"

}

summary() {
    about="${ABOUT[@]}"
    comment "Qubes Release: ${RELEASE}" "" \
            "Master Configuration File(s):" "${about}" "" \
            "builder.conf linked to:" "${CONF_MASTER_DIR}/r${RELEASE}-${CONF_MASTER_FILE}"

    comment "Set SSH_ACCESS to 1 if you can connect to repo via git@ otherwise" \
            "set to 0 for https:// access"
    echo -e "SSH_ACCESS := ${SSH_ACCESS}" >> "${CONF_FILE}"

    if [ "${TEMPLATE}" == "1" ]; then
        comment "Only build templates (comment out to build all of Qubes)"
        echo -e 'COMPONENTS := $(TEMPLATE)' >> "${CONF_FILE}"
        echo -e 'DIST_DOM0 :=\n' >> "${CONF_FILE}"
    fi

    cat >> "${CONF_FILE}" <<'EOF'

.PHONY: get-vms
get-vms::
	@echo $(DISTS_VM)

about::
	@echo "setup.conf"
EOF

    info "New configuration file written to: ${CONF_FILE}"
    debug "$(cat ${CONF_FILE})"
    info
}

instructions() {
read -r -d '' LAST_WORDS <<'EOF' || true

Build Steps
-----------
make get-sources
make template-modules
make template
EOF

info "${LAST_WORDS}"
}


# ------------------------------------------------------------------------------
# Run sections
# ------------------------------------------------------------------------------
clear
installDialog

# Link proper config files based on Qubes release picked
{
    # Move setup.conf out of the way if it exists 
    if [ -f "${CONF_FILE}" ]; then
        mv "${CONF_FILE}" "${CONF_FILE_OLD}"
    fi

    # Copy the examples/nrgaway.conf file to builder.conf
    if ! [ -f "builder.conf" ]; then
        # Choose Qubes version to build (2 or 3)
        chooseVersion && RELEASE=2 || RELEASE=3

        ln -fs "${CONF_MASTER_DIR}/r${RELEASE}-${CONF_MASTER_FILE}" builder.conf
    else
        # Parse about to determine version
        RELEASE=($(make -B release))
    fi

    DISTS_VM=($(make -B get-vms))
    ABOUT=($(make -B about))

    if [ -f "${CONF_FILE_OLD}" ]; then
        SELECTED_DISTS_VM=($(BUILDERCONF="${CONF_FILE_OLD}" make -B get-vms))
    fi
}

# Choose if user has git ssh (commit) or http access to private repos
sshAccessDialog && SSH_ACCESS=1 || SSH_ACCESS=0

# Choose to build a complete system or templates only
templateOnlyDialog && TEMPLATE=1 || TEMPLATE=0

# Verify signing keys and download and verify if required
checkKeys

# Select which templates to build
chooseDistsDialog DISTS

# Write custom setup.conf configuration data
writeConfiguration ${DISTS[@]}

# Display a summary of options selected
clear
summary

# Display instructions on how to build
instructions
