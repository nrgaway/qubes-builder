#! /usr/bin/env python
# vim: set ft=python ts=4 sw=4 sts=4 et :
# -*- coding: utf-8 -*-

# repo --- A Git Repo Management Tool
#
# Copyright (C) 2015  Jason Mehring
#
# License: GPL-2+
#
# ------------------------------------------------------------------------------
#
#               SH...... pip install sh
#               https://amoffat.github.io/sh
#
'''
# The Makefile configuration file must contain these additonal targets:

# SRC_DIR is the relative path from the directory where your Makefile resides
SRC_DIR := qubes-src

# Returns variable value
# Example usage: GET_VAR=DISTS_VM make get-var
.PHONY: get-var
get-var::
	@GET_VAR=$${!GET_VAR}; \
	echo "$${GET_VAR}"

# Each included Makefile configuration sould also include and about to be
# able to identify which configuration files are being used
.PHONY: about
about::
	@echo "extended-rules.conf"

# To automatically add remotes and track a remote branch also add the `TRACK_REPO`
# variable to your Makefile configuration using the sample structure listed below:
TRACK_REPO :=
TRACK_REPO += builder-fedora:master:marmarek:master
TRACK_REPO += builder-fedora:feature_branch:marmarek:master
TRACK_REPO += builder-debian:master:marmarek:master
TRACK_REPO += <local repo name>:<local branch>:<remote repo>:<remote branch>

# GIT_REMOTE_BASEURL
# The default remote GIT_REMOTE_BASEURL is `https://github.com`.  Set this variable
# to something else if needed within the Makefile configuration.
'''

from __future__ import unicode_literals

import sys
import os
import locale
import re
import argparse

BASE_DIR = os.getcwd()
LIBS_DIR = os.path.join(BASE_DIR, 'libs')
if os.path.exists(LIBS_DIR) and os.path.isdir(LIBS_DIR):
    if LIBS_DIR not in sys.path:
        sys.path.insert(1, LIBS_DIR)

import sh
from ansi import ANSIColor

# This is almost always a good thing to do at the beginning of your programs.
locale.setlocale(locale.LC_ALL, '')


class Makefile:
    '''
    '''
    GIT_REMOTE_BASEURL = 'https://github.com/'

    def __init__(self, directory):
        ''''''
        self.options = {}
        self.directory = os.path.abspath(directory)
        self.src_dir = os.path.join(directory, self.get_var('SRC_DIR').strip())

        git_baseurl = self.get_var('GIT_REMOTE_BASEURL').strip()
        self.git_baseurl = git_baseurl if git_baseurl else self.GIT_REMOTE_BASEURL

    def get_var_object(self, var):
        '''
        Returns the raw sh output object which contains many attrs like stderr,
        etc.
        '''
        from sh import make
        env = os.environ.copy()
        env['GET_VAR'] = var
        cmd = '--silent --always-make -C {0} get-var'.format(self.directory)
        return make(cmd.split(), _env=env)

    def get_var(self, var):
        return self.get_var_object(var).stdout


def contains(expressions, text):
    for expression in expressions:
        if re.search(r'(?sm){0}'.format(expression), text):
            return True
        #if expression in text:
        #    return True
    return False


def out(path, sh_result):
    ansi = ANSIColor()
    git = sh.git.bake(_cwd=path)
    branch = git('rev-parse', '--abbrev-ref', 'HEAD').stdout.strip()
    print
    print '================================================================================'
    print '{ansi[bold]}{ansi[blue]}{0}{ansi[normal]} [{1}]'.format(path, branch, ansi=ansi)
    print '================================================================================'
    print '{ansi[red]}{0}{ansi[normal]}'.format(sh_result.stdout.strip(), ansi=ansi)
    print


def walk(function, **kwargs):
    makefile_directory = kwargs['makefile_directory']
    fetch = kwargs['fetch']

    dirs = []
    cache = []
    makefile = Makefile(makefile_directory)

    # Make paths absolute
    if kwargs['dirs']:
        for path in kwargs['dirs']:
            dirs.append(os.path.abspath(path))
    else:
        for path in os.listdir(makefile.src_dir):
            dirs.append(os.path.join(makefile.src_dir, path))

        if kwargs['include_basedir'] and makefile_directory not in dirs:
            dirs.append(makefile.directory)

    for path in dirs:
        if not os.path.isdir(path):
            continue

        if path in cache:
            continue
        else:
            cache.append(path)

        git = sh.git.bake(_cwd=path)

        # Fetch
        if fetch:
            print 'Fetching for: ', path
            git.fetch('--all')

        function(path, makefile)


def remotes(path, makefile):
    track_list = makefile.get_var('TRACK_REPO').split()
    if not track_list:
        return

    ansi = ANSIColor()

    for track_item in track_list:
        track_path, branch, remote, remote_branch = track_item.split(':')
        track_path = os.path.abspath(os.path.join(makefile.src_dir, track_path))

        if track_path != path:
            continue

        print 'Checking remotes for: {0} [{1}]'.format(path, branch)

        if not os.path.exists(path) or not os.path.isdir(path):
            continue

        git = sh.git.bake(_cwd=path)

        # Add git remote...
        origin = git.remote('-v').stdout
        match = re.search(r'origin[\s]+.*[/](.+)\s+\(fetch\).*', origin)

        # XXX: Allowing exception to be raised if no match so was can deal with implementing it later
        remote_url = '{0}{1}/{2}'.format(makefile.git_baseurl, remote, match.group(1).strip())

        if not re.search(r'(?m){0}'.format(remote_url), origin):
            print '{ansi[bold]}{ansi[green]}Adding remote {0}: {1}{ansi[normal]}'.format(remote, remote_url, ansi=ansi)
            git.remote.add(remote, remote_url)

            # Fetch
            print git.fetch('--all')

        # Watch remote branch
        try:
            if branch == git('rev-parse', '--abbrev-ref', 'HEAD').stdout.strip():
                print git.branch('-u', '{0}/{1}'.format(remote, remote_branch), branch)
                break
        except sh.ErrorReturnCode:
            pass


def status(path, makefile):
    git = sh.git.bake(_cwd=path)

    branch = git('rev-parse', '--abbrev-ref', 'HEAD').stdout.strip()
    print 'Checking status for: {0} [{1}]'.format(path, branch)

    ignore = []
    #ignore = [
    #    'HEAD detached',
    #    'Not currently on any branch',
    #    ]

    report = [
        'detached',
        'diverged',
        'Your branch is ahead',
        'Your branch is behind',
        'Changes not staged for commit',
        'Untracked files',
        ]

    result = git.status()

    if contains(ignore, result.stdout):
        return
    if contains(report, result.stdout):
        out(path, result)


def rebase(path, makefile):
    ignore = [
        'detached',
        'Your branch is ahead',
        'Changes not staged for commit',
        'Not currently on any branch',
        ]

    ansi = ANSIColor()
    git = sh.git.bake(_cwd=path)

    result = git.status()
    if contains(ignore, result.stdout):
        return

    match = re.search(r'(?sm)(Your branch is behind).*\'(?P<remote_branch>.*)\'.*(and can be fast-forwarded)', result.stdout)
    if match:
        branch = git('rev-parse', '--abbrev-ref', 'HEAD').stdout.strip()
        remote_branch = match.groupdict()['remote_branch']

        print '================================================================================'
        print '{ansi[bold]}{ansi[blue]}{0}{ansi[normal]} [{1}]'.format(path, branch, ansi=ansi)
        print '================================================================================'
        print '{ansi[red]}Attempting to rebase local branch {0} with {1}{ansi[normal]}'.format(branch, remote_branch, ansi=ansi)
        print '{ansi[white]}{0}{ansi[normal]}'.format(result.stdout, ansi=ansi)
        result = git.rebase(remote_branch)
        print '{ansi[red]}{0}{ansi[normal]}'.format(result, ansi=ansi)

def test(path, makefile):
    track_list = makefile.get_var('TRACK_REPO').split()
    if not track_list:
        print 'TRACK_REPO not found in configuration files'
        return

    ansi = ANSIColor()
    repo_paths = {}

    # Create a list of repos paths to track
    for track_item in track_list:
        track_path, branch, remote, remote_branch = track_item.split(':')
        track_path = os.path.abspath(os.path.join(makefile.src_dir, track_path))

        # Over-write existing entries
        repo_paths[track_path] = True

    if path in repo_paths:
        print '{ansi[bold]}{ansi[blue]}    Tracking: {ansi[normal]}{0}'.format(path, ansi=ansi)

    else:
        print '{ansi[bold]}{ansi[red]}Not Tracking: {0}{ansi[normal]}'.format(path, ansi=ansi)


def main(argv):
    parser = argparse.ArgumentParser()

    # --- Modes -------------------------------------------------------------------
    subparsers = parser.add_subparsers(dest='mode', help='commands')

    status = subparsers.add_parser('status',
            help='Display git status of all repos')
    status.add_argument('dirs', action='store', default=[], nargs='*')

    rebase = subparsers.add_parser('rebase',
            help='Rebase repos')
    rebase.add_argument('dirs', action='store', default=[], nargs='*')

    remotes = subparsers.add_parser('remotes',
            help='Add remotes to git repos selected in Makefile')
    remotes.add_argument('dirs', action='store', default=[], nargs='*')

    test = subparsers.add_parser('test',
            help='Test TRACK_REPO to make sure paths exist')
    test.add_argument('dirs', action='store', default=[], nargs='*')

    # --- Optionals ---------------------------------------------------------------
    parser.add_argument('-C', '--makefile', dest='makefile_directory',
            action='store', default=os.getcwd(),
            help='Makefile configuration file path')
    parser.add_argument('--nofetch', dest='fetch',
            action='store_false', default=True,
            help='Do not fetch repos before the selected mode is run')
    parser.add_argument('--exclude-basedir', dest='include_basedir',
            action='store_false', default=True,
            help='Do not include Makefile base directory in directory list')

    args = parser.parse_args()
    run_list = []

    # Dispatch mode
    if args.mode in ['status', 'remotes', 'rebase', 'test']:
        print 'DISPATCHING: ', args.mode
        function = globals()[args.mode]
        walk(function, **vars(args))


if __name__ == '__main__':
    main(sys.argv)
    sys.exit(0)
