#! /usr/bin/env python
# -*- coding: utf-8 -*-

# status --- A Git Repo Management Tool
#
# Copyright (C) 2015  Jason Mehring
#
# License: GPL-2+
# ------------------------------------------------------------------------------
# Install 'dialog' program if it does not yet exist
# ------------------------------------------------------------------------------
#
#              SH...... pip install sh
#
'''
# The Makefile configuration file must contain these two additonal targets:

# Returns variable value
# Example usage: GET_VAR=DISTS_VM make get-var
.PHONY: get-var
get-var::
	@GET_VAR=$${!GET_VAR}; \
	echo "$${GET_VAR}"

# Each included Makefile configuration sould also include and about to be
# able to identify which configuration files are being used
about::
	@echo "extended-rules.conf"
'''

from __future__ import unicode_literals

import sys
import os
import subprocess
import locale
import argparse

from textwrap import dedent

BASE_DIR = os.getcwd()
LIBS_DIR =  os.path.join(BASE_DIR, 'libs')
if os.path.exists(LIBS_DIR) and os.path.isdir(LIBS_DIR):
    if LIBS_DIR not in sys.path:
        sys.path.insert(1, LIBS_DIR)

from dialog import Dialog

import sh
import re

# This is almost always a good thing to do at the beginning of your programs.
locale.setlocale(locale.LC_ALL, '')

# Initialize a dialog.Dialog instance
dialog = Dialog(dialog='dialog')
dialog.set_background_title("Qubes Git Repo Management Tool")


def close():
    '''Function to exit.  Maybe restoring some files before exiting.
    '''
    sys.exit()


def dialog_release(release):
    release = str(release)
    default_button = 'yes' if release == '2' else 'no'

    result = dialog.yesno(**{
        'title':  'Choose Qubes Version',
        'width': 60,
        'height': 8,

        'yes_label': 'Release 2',
        'no_label': 'Release 3',
        'default_button': default_button,

        'text': dedent('''\
        Choose which version of Qubes you wish to build.

        Valid options are either the stable release 2 or development release 3 version.
        '''),
    })

    if result == dialog.OK:
        return '2'
    elif result == dialog.CANCEL:
        return '3'
    elif result == dialog.ESC:
        close()

class Makefile:
    '''
    '''
    def __init__(self, makefile):
        ''''''
        self.makefile = makefile

    def get_var(self, var):
        cmd = 'make --silent --always-make -C {0} get-var'.format(self.makefile)
        env = os.environ.copy()
        env['GET_VAR'] = var
        return subprocess.check_output(cmd.split(), env=env)


def remotes(makefile_directory):
    print 'Remotes...'
    makefile = Makefile(makefile_directory)
    src_dir = os.path.join(makefile_directory, makefile.get_var('SRC_DIR').strip())
    track_list = makefile.get_var('TRACK_REPO').split()

    for track_item in track_list:
        path, branch, remote, remote_branch = track_item.split(':')
        path = os.path.abspath(os.path.join(src_dir, path))
        print 'Checking remotes for: ', path

        if not os.path.exists(path) or not os.path.isdir(path):
            continue

        git = sh.git.bake(_cwd=path)

        #
        # Add git remote...
        #
        origin = git.remote('-v').stdout
        match = re.search(r'origin[\s]+.*[/](.+)\s+\(fetch\).*', origin)

        # XXX: Allowing exception to be raised if no match so was can deal with implementing it later
        remote_url = 'https://github.com/{0}/{1}'.format(remote, match.group(1).strip())

        if not re.search(r'(?m){0}'.format(remote_url), origin):
            print 'Adding remote {0}: {1}'.format(remote, remote_url)
            git.remote.add(remote, remote_url)

            # Fetch
            print git.fetch('--all')

        #
        # Watch remote branch
        #
        try:
            print git.branch('-u', '{0}/{1}'.format(remote, remote_branch), branch)
        except sh.ErrorReturnCode:
            pass


def status(makefile_directory, fetch=False):
    print 'Status...'
    makefile = Makefile(makefile_directory)
    src_dir = os.path.join(makefile_directory, makefile.get_var('SRC_DIR').strip())
    dir_list = os.listdir(src_dir)
    cache = []

    for path in dir_list:
        print 'Checking status for: ', path
        path = os.path.join(src_dir, path)
        if not os.path.isdir(path):
            continue

        if path in cache:
            continue
        else:
            cache.append(path)

        def out(path, sh_result):
            print '==============================================================='
            print path
            print(sh_result.stdout)
            print

        git = sh.git.bake(_cwd=path)

        # Fetch
        if fetch:
            git.fetch('--all')

        # Status
        result = git.status()

        ignore = [
            'HEAD detached',
            'Not currently on any branch',
            ]

        report = [
            'Your branch is ahead',
            'Your branch is behind',
            'Changes not staged for commit',
            'Untracked files',
            ]

        def contains(expressions, text):
            for expression in expressions:
                #if re.search(r'(?sm){0}'.format(expression), text):
                #    return True
                if expression in text:
                    return True
            return False

        if contains(ignore, result.stdout):
            continue
        if contains(report, result.stdout):
            out(path, result)


def rebase(makefile_directory):
    print 'Rebase...'
    makefile = Makefile(makefile_directory)
    src_dir = os.path.join(makefile_directory, makefile.get_var('SRC_DIR').strip())
    dir_list = os.listdir(src_dir)
    cache = []

    for path in dir_list:
        print 'Checking rebase status for: ', path
        path = os.path.join(src_dir, path)
        if not os.path.isdir(path):
            continue

        if path in cache:
            continue
        else:
            cache.append(path)

        def out(path, sh_result):
            print '==============================================================='
            print path
            print(sh_result.stdout)
            print

        git = sh.git.bake(_cwd=path)

        # Fetch
        git.fetch('--all')

        # Status
        result = git.status()

        ignore = [
            'Your branch is ahead',
            'Changes not staged for commit',
            'HEAD detached',
            'Not currently on any branch',
            ]

        def contains(expressions, text):
            for expression in expressions:
                #if re.search(r'(?sm){0}'.format(expression), text):
                #    return True
                if expression in text:
                    return True
            return False

        if contains(ignore, result.stdout):
            continue

        match = re.search(r'(?sm)(Your branch is behind).*\'(?P<remote_branch>.*)\'.*(and can be fast-forwarded)', result.stdout)
        if match:
            branch = git('rev-parse', '--abbrev-ref', 'HEAD').stdout.strip()
            remote_branch = match.groupdict()['remote_branch']
            print branch
            print remote_branch
            print result.stdout
            print git.rebase(branch, remote_branch)


def main(argv):
    parser = argparse.ArgumentParser()
    #subparsers = parser.add_subparsers(dest='subparser', help='commands')

    parser.add_argument('-C', '--makefile', dest='makefile_directory', action='store_true', default=os.getcwd(),
                             help='Makefile configuration file path')
    parser.add_argument('--status', action='store_true',
                             help='Display git status of all repos')
    parser.add_argument('--nofetch', dest='fetch', action='store_false', default=True,
                             help='Fetch repos first')
    parser.add_argument('--rebase', action='store_true', default=False,
                             help='Rebase repos')
    parser.add_argument('--remotes', action='store_true',
                             help='Add remotes to git repos selected in Makefile')

    args = vars(parser.parse_args())

    print 'Starting...'
    from pprint import pprint
    pprint(args)

    #if args['dialog_release']:
    #    release = dialog_release(args['dialog_release'])
    #    sys.exit(str(release))

    makefile_directory = os.getcwd()

    # Add Remotes if they do not exist
    if args['remotes']:
        remotes(makefile_directory)

    # Display status only if working directory dirty or branch / remote have
    # different commits available to pull / push
    if args['status']:
        status(makefile_directory, fetch=args['fetch'])

    # Attempt auto rebase
    if args['rebase']:
        rebase(makefile_directory)

if __name__ == '__main__':
    main(sys.argv)
    sys.exit(0)
